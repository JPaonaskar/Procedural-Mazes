<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8" />
        <title>Simple Tiled Mazes</title>
        <style>
            canvas {
                background: #eee;
                display: block;
                margin: 0 auto;
            }
        </style>
    </head>
    <b>
        Tiled Mazes
    </b>
    <p>
        Each chunk is a NxM perfect maze generated by a <a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm#:~:text=exit%2C%20are%20removed.-,Randomized%20depth%2Dfirst%20search,-%5Bedit%5D">depth-first seach</a> with itterative implementation.
        Connections or "holes" are then added to a random tile on each edge to connect the mazes.
    </p>
    <body>
        <canvas id="gameCanvas" width="480" height="576"></canvas>

        <script>
            // get canvas
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");

            // key tracker
            let keys = [];

            // key down
            function keyDownHandler(e) {
                if (!keys.includes(e.key)) {
                    // add key to keys
                    keys.push(e.key);
                }
            }

            // key up
            function keyUpHandler(e) {
                for (let i = 0; i < keys.length; i++) {
                    if (keys[i] == e.key) {
                        // remove key
                        keys.splice(i,1);
                        break;
                    }
                }
            }

            class Chunk {
                // construct chunk (x, y, h, w are defined in numbers of tiles)
                constructor(x, y, w, h, tileSize, color) {
                    this.x = x;
                    this.y = y;
                    this.w = w;
                    this.h = h;
                    this.tileSize = tileSize;
                    this.color = color;

                    // setup generation
                    // set size
                    const rows = 2*this.h;
                    const columns = this.w;
                    
                    // create wall data
                    this.wallData = new Array(rows);
                    for (let row = 0; row < rows; row++) {
                        this.wallData[row] = new Array(columns);

                        // fill with walls (1s)
                        for (let column = 0; column < this.wallData[row].length; column++) {
                            this.wallData[row][column] = 1;
                        }
                    }

                    // stored explored tiles
                    this.explored = new Array(this.h);
                    for (let row = 0; row < this.h; row++) {
                        this.explored[row] = new Array(this.w);
                    }

                    // pointer to keep track of position
                    this.pointerx = Math.floor(this.w / 2);
                    this.pointery = Math.floor(this.h / 2);

                    // index of for loop
                    this.i = 0;

                    this.generated = false;
                }

                spiralSearch(array, x0, y0, targetVal) {
                    // spiral search for unexplored tile
                    let x = x0;
                    let y = y0;
                    let d = 0; // 0 = RIGHT, 1 = DOWN, 2 = LEFT, 3 = UP
                    let s = 1; // chain size

                    // largest distance to edge (to make sure the entire maze boundry is covered)
                    const dist = Math.max(x, y, this.w-x-1, this.h-y-1);

                    // begin search (for number of step out from center) (Alternates from WS and WN)
                    for (let i = 0; i < 2*dist+1; i++) {
                        // loop twice (chains are the same size twice)
                        for (let j = 0; j < 2; j++) {
                            // step across chain
                            for (let k = 0; k < s; k++) {
                                // move in direction
                                if (d == 0) {
                                    x++;
                                }
                                else if (d == 1) {
                                    y++;
                                }
                                else if (d == 2) {
                                    x--;
                                }
                                else if (d == 3) {
                                    y--;
                                }

                                // check if in bounds
                                if (x >= 0 && x < this.w && y >= 0 && y < this.h) {
                                    // check for value
                                    if (array[y][x] == targetVal) {
                                        return [x, y];
                                    }
                                }
                            }
                            // change direction
                            d = (d + 1) % 4;
                        }
                        // increase chain size
                        s++;
                    }
                    // could not find value in array
                    return null;
                }

                getNeighbors(x, y, array, value) {
                    // store size
                    const h = array.length;
                    const w = array[0].length;

                    // check neighbors
                    let neighbors = [];
                    if (y - 1 >= 0 && array[y-1][x] == value) {
                        neighbors.push("N");
                    }
                    if (y + 1 < h && array[y+1][x] == value) {
                        neighbors.push("S");
                    }
                    if (x - 1 >= 0 && array[y][x-1] == value) {
                        neighbors.push("L");
                    }
                    if (x + 1 < w && array[y][x+1] == value) {
                        neighbors.push("R");
                    }
                    // return found neighbors
                    return neighbors;
                }

                connectPaths(px, py, direction) {
                    // connect in direction
                    if (direction == "N") {
                        // break wall and move
                        this.wallData[2*py][px] = 0;
                        py -= 1;
                    }
                    else if (direction == "S") {
                        // break wall and move
                        this.wallData[2*py+2][px] = 0;
                        py += 1;
                    }
                    else if (direction == "L") {
                        // break wall and move
                        this.wallData[2*py+1][px] = 0;
                        px -= 1;
                    }
                    else if (direction == "R") {
                        // break wall and move
                        this.wallData[2*py+1][px+1] = 0;
                        px += 1;
                    }
                    // return moved pointer
                    return [px, py];
                }

                // depth of field search to generate chunk
                generate() {
                    if (this.i < this.w*this.h-1) {
                        // mark as explored
                        this.explored[this.pointery][this.pointerx] = 1;

                        // check neighbors
                        const neighbors = this.getNeighbors(this.pointerx, this.pointery, this.explored, undefined);

                        // if there are no neighbors to move to
                        if (neighbors.length == 0) {
                            // do spiral seach to find new unexplored point
                            const newPointer = this.spiralSearch(this.explored, this.pointerx, this.pointery, undefined);
                            
                            // set pointer to new position
                            this.pointerx = newPointer[0];
                            this.pointery = newPointer[1];

                            // get explored neighbors
                            const neighbors = this.getNeighbors(this.pointerx, this.pointery, this.explored, 1);
                            
                            // pick random explored neighbor
                            let dir = neighbors[Math.floor(Math.random()*neighbors.length)];
                            
                            // make connection to explored neigbor
                            this.connectPaths(this.pointerx, this.pointery, dir);
                        }

                        // pick random neighbor
                        let dir = neighbors[Math.floor(Math.random()*neighbors.length)];
                        
                        // make connection in direction dir and move to that point
                        const newPointer = this.connectPaths(this.pointerx, this.pointery, dir);
                            
                        // set pointer to new position
                        this.pointerx = newPointer[0];
                        this.pointery = newPointer[1];

                        this.i++;
                    }
                    else if (this.i = this.w*this.h) {
                        // add connection to the left
                        this.wallData[2*Math.floor(Math.random()*this.h) + 1][0] = -1;

                        // add connection above
                        this.wallData[0][Math.floor(Math.random()*this.w)] = -1;

                        this.i++;
                        this.generated = true;
                    }
                }

                render() {
                    // loop through wall data and generate each wall
                    for (let row = 0; row < this.wallData.length; row++) {
                        for (let column = 0; column < this.wallData[row].length; column++) {
                            // if wall
                            if (this.wallData[row][column] == 1) {
                                // horizontal walls
                                if (row % 2 == 0) {
                                    // points
                                    const x1 = this.x + column;
                                    const x2 = this.x + column + 1;
                                    const y = this.y + 0.5*row;

                                    // set line style
                                    ctx.strokeStyle = this.color;
                                    ctx.lineWidth = 2;

                                    // draw line :)
                                    ctx.beginPath();
                                    ctx.moveTo(x1*this.tileSize, y*this.tileSize);
                                    ctx.lineTo(x2*this.tileSize, y*this.tileSize);
                                    ctx.stroke();
                                }

                                // vertical walls
                                else if (row % 2 == 1) {
                                    // points
                                    const x = this.x + column;
                                    const y1 = this.y + 0.5*row - 0.5;
                                    const y2 = this.y + 0.5*row + 0.5;

                                    // set line style
                                    ctx.strokeStyle = this.color;
                                    ctx.lineWidth = 2;

                                    // draw line :)
                                    ctx.beginPath();
                                    ctx.moveTo(x*this.tileSize, y1*this.tileSize);
                                    ctx.lineTo(x*this.tileSize, y2*this.tileSize);
                                    ctx.stroke();
                                }
                            }
                        }
                    }
                }

                getNeighboringWalls(x, y) {
                    // check neighbors
                    let neighbors = [];
                    if (y >= 0 && y < this.h && x >= 0 && x < this.w) {
                        if (this.wallData[2*y][x] == 1) {
                            neighbors.push("N");
                        }
                    }
                    if (y >= -1 && y + 1 < this.h && x >= 0 && x < this.w) {
                        if (this.wallData[2*y+2][x] == 1) {
                            neighbors.push("S");
                        }
                    }
                    if (y >= 0 && y < this.h && x >= 0 && x < this.w) {
                        if (this.wallData[2*y+1][x] == 1) {
                            neighbors.push("L");
                        }
                    }
                    if (y >= 0 && y < this.h && x >= -1 && x + 1 < this.w) {
                        if (this.wallData[2*y+1][x+1] == 1) {
                        neighbors.push("R");
                        }
                    }
                    // return found neighbors
                    return neighbors;
                }

                collide(player) {
                    // convert player position to row and column
                    const column = Math.floor(player.x / this.tileSize - this.x)
                    const row = Math.floor(player.y / this.tileSize - this.y)

                    // create collisions for neiboring tiles (accounts for current tile too)
                    const dRow = [1, -1, 0, 0]
                    const dColumn= [0, 0, 1, -1]

                    // loop though each case
                    for (let i = 0; i < 4; i++) {
                        const rowi = row + dRow[i];
                        const columni = column + dColumn[i];
                        // if collision point is in bounds
                        if (rowi >= -1 && rowi <= this.h && columni >= -1 && columni <= this.w) {
                            // get neighboring walls
                            const neighboringWalls = this.getNeighboringWalls(columni, rowi);
                            
                            // collisions
                            if (neighboringWalls.includes("N")){
                                const x1 = (this.x + columni)*this.tileSize;
                                const x2 = (this.x + columni + 1)*this.tileSize;
                                const y = (this.y + rowi)*this.tileSize;
                                player.collide_line(x1, y, x2, y);
                            }
                            if (neighboringWalls.includes("S")){
                                const x1 = (this.x + columni)*this.tileSize;
                                const x2 = (this.x + columni + 1)*this.tileSize;
                                const y = (this.y + rowi + 1)*this.tileSize;
                                player.collide_line(x1, y, x2, y);
                            }
                            if (neighboringWalls.includes("L")){
                                const x = (this.x + columni)*this.tileSize;
                                const y1 = (this.y + rowi)*this.tileSize;
                                const y2 = (this.y + rowi + 1)*this.tileSize;
                                player.collide_line(x, y1, x, y2);
                            }
                            if (neighboringWalls.includes("R")){
                                const x = (this.x + columni + 1)*this.tileSize;
                                const y1 = (this.y + rowi)*this.tileSize;
                                const y2 = (this.y + rowi + 1)*this.tileSize;
                                player.collide_line(x, y1, x, y2);
                            }
                        }
                    }
                }
            }

            class Player {
                constructor(x, y, r, color, a, drag) {
                    // position
                    this.x = x;
                    this.y = y;

                    // size
                    this.r = r;
                    
                    // physics
                    this.vx = 0;
                    this.vy = 0;
                    this.a = a;
                    this.drag = drag;

                    // style
                    this.color = color;
                }

                render() {
                    // draw cicle :)
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.closePath();
                }

                control() {
                    // keys to acceleration
                    if (keys.includes("ArrowUp") || keys.includes("w")) {
                        this.vy -= this.a;
                    }
                    if (keys.includes("ArrowDown") || keys.includes("s")) {
                        this.vy += this.a;
                    }
                    if (keys.includes("ArrowLeft") || keys.includes("a")) {
                        this.vx -= this.a;
                    }
                    if (keys.includes("ArrowRight") || keys.includes("d")) {
                        this.vx += this.a;
                    }
                }

                move() {
                    // collide with boundries
                    // x
                    if (this.x - this.r + this.vx <= 0) {
                        this.vx = Math.abs(this.vx);
                    }
                    else if (this.x + this.r + this.vx>= canvas.width) {
                        this.vx = -Math.abs(this.vx);
                    }
                    // y
                    if (this.y - this.r + this.vy <= 0) {
                        this.vy = Math.abs(this.vy);
                    }
                    else if (this.y + this.r + this.vy >= canvas.height) {
                        this.vy = -Math.abs(this.vy);
                    }

                    // move
                    this.x += this.vx;
                    this.y += this.vy;

                    // drag
                    this.vx *= 1 - this.drag;
                    this.vy *= 1 - this.drag;
                }

                collide_line(x1, y1, x2, y2) {
                    // set line style
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;

                    // draw line :)
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();

                    // set up quadratic fromula
                    const a = Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)
                    const b = 2*(x1 - this.x)*(x2 - x1) + 2*(y1 - this.y)*(y2 - y1)
                    const c = Math.pow(x1 - this.x, 2) + Math.pow(y1 - this.y, 2) - Math.pow(this.r, 2)
                    const disc = Math.pow(b, 2) - 4*a*c

                    // collsion "time"
                    let tc = null

                    // one possible collsion point
                    if (disc == 0) {
                        const t = -b / (2*a)

                        // if on segment
                        if (t >= 0 && t <= 1) {
                            // save collsion "time"
                            tc = t
                        }
                        else {
                            // not colliding so exit function
                            return;
                        }
                    }
                    // two possible collision points
                    else if (disc > 0) {
                        const t1 = (-b + Math.sqrt(disc)) / (2*a)
                        const t2 = (-b - Math.sqrt(disc)) / (2*a)

                        // center case
                        if ((t1 >= 0 && t1 <= 1) && (t2 >= 0 && t2 <= 1)) {
                            // save collsion "time"
                            tc = 0.5*(t1 + t2)
                        }
                        // edge case 1
                        else if (t1 >= 0 && t1 <= 1) {
                            // save collsion "time"
                            tc = 0.5*t1
                        }
                        // edge case 2
                        else if (t2 >= 0 && t2 <= 1) {
                            // save collsion "time"
                            tc = 0.5*(1 + t2)
                        }
                        // not colliding
                        else {
                            // not colliding so exit function
                            return;
                        }
                    }
                    else {
                            // not colliding so exit function
                        return;
                    }

                    // collision point
                    const cx = (x2 - x1)*tc + x1
                    const cy = (y2 - y1)*tc + y1

                    // normal (line normal but approximates rounded caps of lines)
                    const normx = this.x - cx
                    const normy = this.y - cy
                    const mag2Norm = Math.pow(normx, 2) + Math.pow(normy, 2)

                    // project velocity on normal
                    const dot = normx*this.vx + normy*this.vy

                    // if velocity is towards the line
                    if (dot < 0) {
                        // change velocity by twice the projection on the normal
                        this.vx -= 2*dot / mag2Norm * normx
                        this.vy -= 2*dot / mag2Norm * normy
                    }
                }
            }

            // create chunks
            let chunk1 = new Chunk( 1,  1, 9, 11, 24, "black");
            let chunk2 = new Chunk(10,  1, 9, 11, 24, "green");
            let chunk3 = new Chunk( 1, 12, 9, 11, 24, "green");
            let chunk4 = new Chunk(10, 12, 9, 11, 24, "black");

            // create player
            let player = new Player(0.5*canvas.width-12.0,
                                    0.5*canvas.height-12.0,
                                    5.0,
                                    "#0095DD",
                                    0.5,
                                    0.1)

            function update() {
                // clear
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // render chunks
                chunk1.render();
                chunk2.render();
                chunk3.render();
                chunk4.render();

                // if chunks are generated move
                if (chunk1.generated && chunk2.generated && chunk3.generated && chunk4.generated) {
                    // render player
                    player.render();

                    // control player
                    player.control();

                    // collide with maze walls in chuncks
                    chunk1.collide(player);
                    chunk2.collide(player);
                    chunk3.collide(player);
                    chunk4.collide(player);

                    // move player (after collisions to avoid clipping)
                    player.move();
                }
                // generate chunks
                else {
                    chunk1.generate()
                    chunk2.generate()
                    chunk3.generate()
                    chunk4.generate()
                }
            }

            // event listeners
            document.addEventListener("keydown", keyDownHandler, false);
            document.addEventListener("keyup", keyUpHandler, false);

            // run update
            setInterval(update, 25);
        </script>
    </body>
</html>